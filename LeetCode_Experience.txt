*****************************************************************************************************************************************
                                Experience when coding
*****************************************************************************************************************************************
1. Split the algorithm into sub functions as best as you can.
   When implementing each function, you will get much clear mind and would not mess up everything together.
   
2. When solving a problem about optimum solution, the first method comes to your mind should be dynamic programming.
The very first thing about DP is to desolve the original problem into sub problems. 
First write the recursion codes. Based on the recursion codes, you can get which is the smallest problem and you can start from there to write DP.

One thing that you should remember is that not only the problem directly asked by the question can be desolved into sub problems, but also some along problems to solve the original problem can also be desovled and be solved by DP.
One typical example is the "Palindrome_Partitioning_II" problem.

3. When a problem requires O(n) time complexity but you cannot figure it out enen racking your brains, then hash table solution should be the first consideration.
Typical example: Longest Consecutive Sequence

So how to use hash table in C++?
    #include <unordered_map>
    unordered_map<int , bool> hashA;
    int newKey = 1;
    hashA[newKey] = true;  //insert
    if(hashA.find(newKey) != hashA.end())  //search
         hashA[newKey] = false;  //modify

4. Do not be so stingy to use more variables.
     If you only consider to use as less variables as possible, you will reuse a variable which you should, which may leads to panic of program.
     Take the Convert_Sorted_List_to_Binary_Search_Tree project for example. You can compare the original and the modified version.


5. Practice the DP problems as many as possible
When solving DP problem, do not consider too much and let yourself "脑子一团浆糊". Just define sub problems well and when writing codes,
make clear what is current problem and what is sub problem.

For example:
Interleaving string
Decode Ways
  从 decode ways这道题目提交4次才成功可以看出，并没有完全理解这样一个原理：子问题和原问题是一模一样的，不要考虑太多！！！ 比如原问题中如果字符串的第一个字符为0，那么
  字符串的decode ways就为0；同样的，对于子问题也是这样呀。当当前字符为0时，那么从当前字符开始的字符串的decode ways就为0.
Subsets II
Scramble String
Combinations 


6. 有些问题不要一味地追求DP解法，如果说用递归解法的复杂度是常量，与问题规模无关，那么我们就完全可以用递归解法了。
比如Restore IP Addreses. 用递归解法的代码量远比DP解法的代码量小得多.
再比如Unique Binary Search Trees中，用非递归的DP解法会造成大量的树的拷贝，而用递归解法就不用大量拷贝。

7. The two directions to split a problem to sub problems:
(1) Decrease the scale of the original problem. The sub problem is the one with a smaller scale
(2) Transform the original data to another data. The sub problem is the one with the same scale as the original problem.

*****************************************************************************************************************************************
                                   Specific Problems
*****************************************************************************************************************************************
1. Evaluate Reverse Polish Notation
(1) Did not consider the negative number
    Last executed input:	["3","-4","+"]
	So when converting the string of "-4" to number, the '-' is taken as an operator....

    
3. Reorder_List

    Original codes:
    ListNode* MergeTwoLists(ListNode* root1, ListNode* root2)
    {
        if (root1 == NULL)
        {
            return root2;
        }
        else if (root2 == NULL)
        {
            return root1;
        }

        ListNode* head = NULL, *tail = NULL;

        while(root1 && root2)
        {
            if (head == NULL)
            {
                head = tail = root1;
            }
            else
            {
                tail->next = root1;
                tail = root1;
            }
			
			(In the above tail = root1, here we set tail->next = root2, so makes us lost the original root1->next !!!)

            tail->next = root2;
            tail = root2;

            root1 = root1->next;
            root2 = root2->next;
        }

        if (root1 == NULL)
            tail->next = root2;
        else
            tail->next = root1;

        return head;
    }
	
	Experience:
	In the list operation, when finishing traverse one node, please go to the next node immediately!!!
	
4. Linked List Cycle II
   
   Original Codes:
	//returns the encouter node and how many nodes node1 and nodes2 passed.
    ListNode* GetEncounterNodeDifferentPace(ListNode* node1, ListNode* node2, int& passCount)
    {
        if (node1 == NULL || node2 == NULL)
        {
            passCount = 0;
            return NULL;
        }

        passCount = 0;

        while(node1 && node2)
        {
            passCount++;

            if (node1 == node2)  << Since node1 and node2 both point to head at first. This condition always succeed!!!
            {
                return node1;
            }

            node1 = node1->next;
            if (node1 == NULL)
                return NULL;

            node2 = node2->next;
            if (node2 == NULL)
                return NULL;
            node2 = node2->next;
        }

        return NULL;        
    }

5. Word Break II 
   Input:	"a", ["a"]
   Output:	["a "]
   Expected:	["a"]
   
    vector<string> wordBreak(string s, unordered_set<string> &dict) {
        int n = s.size();
        vector<string> resultCollection;

        if(n == 0)
            return resultCollection;

        vector<string>*  stringBreakStore = new vector<string>[n+1];
        stringBreakStore[n].push_back("");

        string substr, res; int size, len;

        for(int i = n - 1; i >= 0; i--)
        {
            size = n - i;
            for(int j = 0; j < size; j++)
            {
                substr = s.substr(i, j+1);
                if(dict.find(substr) == dict.end())
                    continue;

                if(stringBreakStore[i+j+1].size() == 0)
                    continue;

                len = stringBreakStore[i+j+1].size();
                for(int k = 0; k < len; k++)
                {
                    res.clear();
                    res = substr;
					res += " "; (<<<<<<<<< When stringBreakStore[i+j+1].at(k) is not "" can we add the space)
					res += stringBreakStore[i+j+1].at(k);
                    stringBreakStore[i].push_back(res);
                }
            }
        }

        size = stringBreakStore[0].size();
        for(int i = 0; i < size; i++)
            resultCollection.push_back(stringBreakStore[0].at(i));

        delete [] stringBreakStore;
        return resultCollection;     
    }

    6. Interleaving_String
    See the different versions of the code, we did not consider too well about two character same case.

    7. Minimum Window Substring
    This is a typical and complex code algorithm!

    8. Sort Colors
    虽然代码一次成功，但是自己想出来的这个思想还是应当仔细体会

    9. Search_a_2D_Matrix
    对于mid的值没有处理好导致死循环。

    10. Set matrix zeros
    没有考虑到在利用第一行和第一列作为标记位时，将原值覆盖掉了，从而造成对第一行和第一列的处理错误。